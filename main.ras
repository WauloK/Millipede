program MyProject;
@use "Screen"
@use "Memory"
@use "Compression"
@use "Font"
@use "Input"
@use "Sound"
@use "Functions"
@use "Sprite"

@export "images/title.flf" "title.bin" 256

var  
	// Get data for the title screen
	data : incbin("title.bin") compressed;
	// Constants to make code easier to read
	const gridWidth : byte = 32;
	const gridHeight : byte = 14;
	const milliLength : byte = 12;
	const fleaSprite : byte = 9;
	const snakeSprite : byte = 10;
	const snakeDeathSprite : byte = 20;
	const mushroomSprite : byte = 1;
	const mushroomSpriteEnd : byte = 5;
	const milliSprite : byte = 12;
	const milliSpriteEnd : byte = 17;
	const milliBody : byte = 5;
	const milliHead : byte = 6;
	const fleaDeathSprite : byte = 20;
	const PlayerYMin : byte = 42;
	const PlayerYMax : byte = 58;
	const PlayerXMax : byte = 31;
	const MilliYMin : byte = 10;
	const MilliYMax : byte = 12;
	const PlayerMoveCount : byte = 3;
	const MilliMoveCount : byte = 4;
	const fleaMovespeed : byte = 2;
	const screenYOffset : byte = 6;
	const Sfx_Gamestart : byte = 1;
	const Sfx_Playershoot : byte = 2;
	const Sfx_Flea : byte = 3;
	const Sfx_FleaDead : byte = 4;
	const Sfx_PlayerDead : byte = 5;
	// Millipede segment flags
	const Flag_MovingLeft : byte = 1;	// No = 0. Yes = 1
	const Flag_MovingRight : byte = 2; // No = 0. Yes = 1
	const Flag_MovingUp : byte = 4;	// Moving Up. No = 0. Yes = 1.
	const Flag_MovingDown : byte = 8; // Moving Down. No = 0. Yes = 1.
	const Flag_Head : byte = 16;		// No = 0. Yes = 1.
	const Flag_Poisoned : byte = 32;	// No poison = 0. Poisoned = 1.
	const Flag_Alive: byte = 64;		// This segment alive? No = 0. Yes = 1.
	
	// Other variables	
	tempint : Integer;
	mychar : string = "A";
	myp, mym : pointer;
	strpos : byte = 0;
	Value, BitFlag: byte;
	milliMoveSpeed : byte;
	// Set up an array for the mushrooms
	gameGrid : array[gridWidth*gridHeight] of byte;
	// An array of random numbers 0-31 for putting mushrooms in the grid
	gridRandoms : array[256] of byte = (24,4,29,22,26,24,26,19,21,8,23,20,20,1,30,27,19,2,16,20,11,2,18,17,1,9,14,9,29,29,17,8,7,5,2,0,31,10,22,24,8,19,1,29,7,25,29,20,4,15,12,25,0,11,23,6,6,31,21,2,26,29,10,15,20,23,30,30,31,9,6,2,14,12,28,22,7,21,6,1,20,31,4,25,30,8,11,24,17,24,27,14,20,9,18,18,30,4,28,6,18,4,20,9,26,12,4,12,26,19,18,12,25,30,5,15,14,5,23,24,4,27,13,4,26,11,26,20,22,16,5,28,1,2,18,31,20,20,17,21,6,11,24,0,10,24,31,2,27,12,19,31,20,8,13,19,4,18,6,7,30,2,27,19,16,7,1,18,17,31,6,24,17,1,16,6,6,20,0,29,16,23,3,16,18,1,28,28,21,12,17,25,18,0,22,21,15,5,10,18,24,17,6,31,5,23,12,1,17,20,12,30,25,3,10,26,30,5,30,11,0,26,19,16,11,23,11,18,14,27,26,20,25,23,28,17,13,31,15,19,29,25,9,3,29,27,1,14,14,30,15,16,31,31,18,21);
	smallSprites: array[] of byte =(0,0,0,0,20,85,40,40,20,85,40,8,20,85,0,0,20,0,0,0,40,170,60,60,40,170,60,0,40,170,0,0,40,0,0,0,60,223,255,204,20,215,85,20,20,0,0,0,20,85,85,20,23,85,85,23,20,85,85,215,212,85,85,212,215,85,85,20,0,16,0,0,0,16,4,0,0,4,16,0,68,17,68,17,0,48,0,0,0,48,12,0,0,12,48,0,204,51,204,51);
	bigSprites: array[] of byte = (0,0,48,12,199,211,15,240,48,12,48,12,48,12,204,51,7,208,15,24,0,48,12,192,3,240,15,12,48,7,208,63,252,192,3,0,0,48,12,204,51,7,208,15,24,0,48,12,192,3,0,0,204,204,48,48,55,124,15,255,3,252,0,0,204,204,48,48,55,115,15,255,3,252,0,0,48,48,48,48,55,124,15,255,3,252,0,0,204,204,48,48,55,115,15,255,3,252,0,0,51,51,12,12,61,220,255,240,63,192,0,0,51,51,12,12,205,220,255,240,63,192,0,0,12,12,12,12,61,220,255,240,63,192,0,0,51,51,12,12,205,220,255,240,63,192,204,51,55,220,208,67,193,7,55,220,204,51,0,0,204,51,55,204,51,220,204,51,0,0,0,4,16,0,0,0,0,0,0,0,0,0,0,0,1,192,3,64,0,0,0,0,0,0);
	// Array to look up Y values to speed things up
	lookupGridY : array[gridHeight] of Integer = BuildTable("i*GRIDWIDTH");
	lookupScreenY : array[gridHeight] of Integer = BuildTable("i*4");
	screenYtogridY : array[56] of byte = (0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,6,6,6,6,7,7,7,7,8,8,8,8,9,9,9,9,10,10,10,10,11,11,11,11,12,12,12,12,13,13,13,13);
	p, q, s, t, u, v, w, x, y : byte;
	message : string = "Press 'S' to start! You can use either Joystick or Keys:QA = Up/Down and M, = Left/Right Space to fire. Millipede was developed by Jason Oakley / Blue Bilby using TRSE. Check out more stuff at BlueBilby.com ... ";
	strlen : byte = 210;
	milliSegments_record = record
		x,y : byte;
		flags : byte;
	end;
	playerSnake_record = record
		moveCount : byte;
		x,y : byte;
	end;
	playerBullet_record = record
		fired : boolean;
		moveCount : byte;
		x,y : byte;
	end;
	flea_record = record
		enabled : boolean;
		dropCount : byte;
		shotCount : byte;
		moveSpeed : byte;
		animFrame : byte;
		x,y : byte;
	end;
	gameStats_record = record
		lives, level : byte;
		score : Integer;
		hiScore : Integer;
		gameRunning : boolean;
	end;
	playerBullet : playerBullet_record;
	playerSnake : playerSnake_record;
	gameStats : gameStats_record;
	fleaEnemy : flea_record;
	milliSegments : array[milliLength] of milliSegments_record;	

// Procedures	

// Bitwise functions
function IsBitSet(Value, BitFlag: global byte): Boolean;
begin
	IsBitSet := Value & BitFlag;
end;
function SetBit(Value, BitFlag: global byte): Boolean;
begin
	SetBit := Value | BitFlag;
end;
function ResetBit(Value, BitFlag: global byte): Boolean;
begin
	ResetBit := Value - BitFlag;
end;

// Draw and manage Title Screen
procedure TitleScreen();
begin
	myp := #mychar;
	mym := #message;
	v := 0;
	// Keep titlescreen going until S pressed
	while (Input::GetPressedKey() <> Input::Key_S) do
	begin
		// Draw new char in the onscreen scroll every 4 pixels
		if (v = 0) then
		begin
			v := 4;
			myp[0] := mym[strpos];
			Font::DrawTextAt(#mychar,31,58,false);
			if (strpos < strlen) then strpos := strpos + 1 else strpos := 0;
		end;
		for u := 0 to 200 do wait(50);	
		// Smooth scroll the message 1 pixel at a time
		Screen::doSmoothScroll(30559,5);
		v := v - 1;
	end;	
	gameStats.gameRunning := true;
end;

// Sound effects manager
procedure PlaySound(u : global byte);
begin
	// Game start sfx
	case u of
		Sfx_Gamestart:
			begin
				Sound::Play(80,50);
				Sound::Play(50,50);
			end;
		Sfx_Playershoot:
			begin
				Sound::Play(80,10);
				Sound::Play(100,10);
				Sound::Play(120,10);
			end;
		Sfx_Flea:
			begin
				Sound::Play(fleaEnemy.y * 5,3);
			end;
		Sfx_FleaDead:
			begin
				Sound::Shoot(450,200);
			end;
		Sfx_PlayerDead:
			begin
				Sound::Explode();
			end;
	end;
end;

// Draw numbers on the screen padded and with trailing zeroes
procedure DrawPadded(zscore : Integer; x, y: global byte);
begin
	u := x;
	if (zscore < 1) then 
	begin
		Font::DrawTextAt("0",u+6,y,false);
		return;
	end;
	if (zscore < 10000) then x := x + 1;
	if (zscore < 1000) then x := x + 1;
	if (zscore < 100) then x := x + 1;
	if (zscore < 10) then x := x + 1;
	Functions::IntegerToString(zscore);
	Font::DrawTextAt(#Functions_s,x,y,false);	
	Font::DrawTextAt("0",u+6,y,false);
end;

// Draw Headsup Display.
procedure DrawHUD();
begin
	// Draw lives
	Screen::SetPen(3);
	Font::DrawTextAt("Score:",19,0,false);
	Font::DrawTextAt("Lives:",0,0,false);
	Font::DrawTextAt("Hi:",8,0,false);
	Screen::SetPen(1);
	DrawPadded(gameStats.score,24,0);
	DrawPadded(gameStats.hiScore,10,0);
	Functions::ByteToString(gameStats.lives);
	Font::DrawTextAt(#Functions_s,6,0,false);
end;

// Initialise stuff
procedure InitialiseGame();
begin
	// Scroll titlescreen off to the left
	for v := 0 to 32 do
	begin
		Screen::doCoarseScroll(28672,63);
		for u := 0 to 30 do wait(140);	
	end;
	// Initialise grid
	for u := 0 to 255 do gameGrid[u] := 0;
	for u := 0 to (gridWidth * gridHeight) - 255 do gameGrid[u+256] := 0;
	// Initialise millipede
	for u:= 0 to milliLength do
	begin
		milliSegments[u].flags := 74;	 // Initial direction set to right, down and set to alive body segment.
		milliSegments[u].y := 255; // A large number to note the segment is not on the grid yet.
	end;
	milliSegments[0].flags := 90;	 // Alive, direction right, down and head segment.
	milliMoveSpeed := MilliMoveCount;
	// Initialise variables
	gameStats.lives := 3;
	gameStats.score := 0;
	gameStats.level := 1;
	playerSnake.x := 16;
	playerSnake.y := 58;
	playerSnake.moveCount := PlayerMoveCount;
	playerBullet.moveCount := 4;
	playerBullet.fired := false;
	fleaEnemy.enabled := false;
	fleaEnemy.shotCount := 0;
	DrawHUD();
	// Draw player sprite
	Sprite::SetData(#smallSprites);
	Sprite::SetSize(1,4);	
	Sprite::DrawAt(playerSnake.x,playerSnake.y,snakeSprite);
	if (gameStats.level = 1) then return;
end;

// Initialise the mushrooms in an array grid and display
procedure DrawGrid();
begin
	Sprite::SetData(#smallSprites);
	Sprite::SetSize(1,4);
	// Playfield grid array
	for y := 0 to gridHeight - 1 do
	begin
		x := Functions::getRandFromArray(#gridRandoms);
		tempint := lookupGridY[y] + x;
		gameGrid[tempint] := mushroomSprite;
		Sprite::DrawAt(x,screenYOffset+lookupScreenY[y],mushroomSprite);
		x := Functions::getRandFromArray(#gridRandoms);
		tempint := lookupGridY[y] + x;
		gameGrid[tempint] := mushroomSprite;
		Sprite::DrawAt(x,screenYOffset+lookupScreenY[y],mushroomSprite);
	end;
end;

// Calculate the player's position in the mushroom grid
// to compare if colliding with mushrooms or millipede
function GetGridLocVal(v,w : global byte):byte;
begin
	//w := (w - screenYOffset) / 4 + 1;
	tempint := lookupGridY[w]+v;
	// Return value from function call
	GetGridLocVal := gameGrid[tempint];
end;

// Update value at grid location
procedure SetGridLocVal(v,w,t : global byte);
begin
	//w := (w - screenYOffset) / 4 + 1;
	tempint := lookupGridY[w]+v;
	// Update grid value
	gameGrid[tempint] := t;
end;

// Update Lives HUD
procedure SubtractLife();
begin
	gameStats.lives := gameStats.lives - 1;
	// Check if Game Over
	if (gameStats.lives = 0) then
	begin
		// Player dead. TODO
		gameStats.gameRunning := false;
	end;
	DrawHUD();
end;

// Add points to player's score
procedure AddScore(t : global byte);
begin
	gameStats.score := gameStats.score + t;
	DrawHUD();
end;

// Delete a sprite
procedure DeleteSprite(x, y : global byte);
begin
	tempint := #screen + Screen::tab32[y] + x;
	asm("
	ld a,[tempint+1]
	ld h,a
	ld a,[tempint]
	ld l,a
	ld de,#0020
	ld (hl),#00
	add hl,de
	ld (hl),#00
	add hl,de
	ld (hl),#00
	add hl,de
	ld (hl),#00
	add hl,de	
	");
end;

// DrawBullet
procedure DrawBullet(x,y : global byte);
begin
	tempint := #screen + Screen::tab32[y] + x;
	Screen::Poke(tempint,20);
end;

// Delete Bullet
procedure DeleteBullet(x,y : global byte);
begin
	tempint := #screen + Screen::tab32[y] + x;
	Screen::Poke(tempint,0);	
end;

// Get player input and move snake head
procedure ControlPlayer();
begin
	// Get player input
	u := Input::GetJoystick(1);
	v := Input::GetJoystick(2);
	w := Input::GetPressedKey();
	
	// Test for player movement
	if (u = Input::Joy_None and (v = Input::Joy_None and (w = Input::Key_None))) then return;
	// Player shooting
	if (u = Input::Joy_Fire or (v = Input::Joy_Fire or (w = Input::Key_SPC))) then
	begin
		// Test if a bullet already exists onscreen. Snake can only shoot once at a time
		if (playerBullet.fired) then return;
		playerBullet.fired := true;
		PlaySound(Sfx_Playershoot);
		playerBullet.x := playerSnake.x;
		playerBullet.y := playerSnake.y - 1;
		DrawBullet(playerBullet.x,playerBullet.y);
		return;
	end;		
  // Erase player sprite
	DeleteSprite(playerSnake.x,playerSnake.y);
	// Check if player wants to move UP
	if (u = Input::Joy_Up or (v = Input::Joy_Up or (w = Input::Key_Q))) then
	begin
		// Make sure we're not already at the top of the player area
		if (playerSnake.y > PlayerYMin) then 
		begin
			// Move player y pos
			playerSnake.y := playerSnake.y - 2;
			// Test if we're colliding with a mushroom. If so, move player y back
			if (GetGridLocVal(playerSnake.x,screenYtogridY[playerSnake.y - screenYOffset]) > 0) then playerSnake.y := playerSnake.y + 1;
		end;
	end;
	if (u = Input::Joy_Down or (v = Input::Joy_Down or (w = Input::Key_A))) then
	begin
		if (playerSnake.y < PlayerYMax) then 
		begin
			// Due to player sprite being 4 pixels high we need to check 4 below the Y value.
			playerSnake.y := playerSnake.y + 4;
			// If a mushroom is below the player, move the y back to where it was, otherwise move one pixel down
			if (GetGridLocVal(playerSnake.x,screenYtogridY[playerSnake.y - screenYOffset]) > 0) then playerSnake.y := playerSnake.y - 4 else playerSnake.y := playerSnake.y - 3;
		end;
	end;	
	if (u = Input::Joy_Left or (v = Input::Joy_Left or (w = Input::Key_M))) then
	begin
		if (playerSnake.x > 0) then
		begin
			playerSnake.x := playerSnake.x - 1;
			if (GetGridLocVal(playerSnake.x,screenYtogridY[playerSnake.y - screenYOffset]) > 0) then playerSnake.x := playerSnake.x + 1;
			// Test bottom of sprite
			if (GetGridLocVal(playerSnake.x,screenYtogridY[playerSnake.y + 3 - screenYOffset]) > 0) then playerSnake.x := playerSnake.x + 1;
		end;
	end;
	if (u = Input::Joy_Right or (v = Input::Joy_Right or (w = Input::Key_COMMA))) then
	begin
		if (playerSnake.x < PlayerXMax) then
		begin
			playerSnake.x := playerSnake.x + 1;
			if (GetGridLocVal(playerSnake.x,screenYtogridY[playerSnake.y - screenYOffset]) > 0) then playerSnake.x := playerSnake.x - 1;		
			// Test bottom of sprite
			if (GetGridLocVal(playerSnake.x,screenYtogridY[playerSnake.y + 3 - screenYOffset]) > 0) then playerSnake.x := playerSnake.x - 1;			
		end;
	end;
	// Draw player sprite at new location
	Sprite::DrawAt(playerSnake.x,playerSnake.y,snakeSprite);
end;

// Check if we need to put a flea on the screen
procedure DoFleaCheck();
begin
	t := 0;
	for u := 0 to 160 do
	begin
		v := gameGrid[u+256];
		if (v > mushroomSprite - 1 and (v < mushroomSpriteEnd)) then t := t + 1;
		if (t > 5) then return;
	end;
	fleaEnemy.enabled := true;
	fleaEnemy.x := Functions::getRandFromArray(#gridRandoms);
	fleaEnemy.y := screenYOffset + 4;
	fleaEnemy.moveSpeed := fleaMovespeed;
	fleaEnemy.shotCount := 0;
	Sprite::DrawAt(fleaEnemy.x, fleaEnemy.y, fleaSprite);
end;

// Player fired
procedure MoveBullet();
begin
	// Erase sprite
	DeleteBullet(playerBullet.x,playerBullet.y);
	playerBullet.y := playerBullet.y - 1;
	if (playerBullet.y < screenYOffset + 1) then
	begin
		playerBullet.fired := false;
		return;
	end;
	// Only check every 4 pixels moved
	playerBullet.moveCount := playerBullet.moveCount - 1;
	// Reset movement counter
	playerBullet.moveCount := 4;
	// Find out any values in the grid at the bullet location
	t := GetGridLocVal(playerBullet.x,screenYtogridY[playerBullet.y - screenYOffset]);
	// Collided with something on the grid
	if (t > 0) then
	begin
		// Turn bullet off
		playerBullet.fired := false;
		// Test for mushies
		if (t > mushroomSprite - 1 and (t < mushroomSpriteEnd)) then
		begin
			// Mushy at this grid loc
			if (t < mushroomSpriteEnd) then
			begin
				DeleteSprite(v,lookupScreenY[w]+screenYOffset);	
				t := t + 1;
				// Update value in grid location
				SetGridLocVal(playerBullet.x,screenYtogridY[playerBullet.y - screenYOffset],t);
				// Draw new grid sprite
				Sprite::DrawAt(v,lookupScreenY[w]+screenYOffset,t);				
			end;
			if (t = mushroomSpriteEnd) then 
			begin
				// Delete mushy
				SetGridLocVal(playerBullet.x,screenYtogridY[playerBullet.y-screenYOffset],0);
				// Draw new grid sprite
				DeleteSprite(v,lookupScreenY[w]+screenYOffset);				
				AddScore(1);
				// See if number of mushies in player area needs updating
				if (fleaEnemy.enabled = false) then DoFleaCheck();
			end;
		end;
	end;
	// Draw sprite at new location onscreen
	if (playerBullet.fired) then DrawBullet(playerBullet.x,playerBullet.y);
end;

procedure CheckFleaShot();
begin
	if (fleaEnemy.x <> playerBullet.x) then return;
	t := playerBullet.y;
	u := fleaEnemy.y;
	v := fleaEnemy.y + 5;
	if (t < v and (t > u)) then
	// Flea shot by player
	begin
		// Erase bullet
		DeleteBullet(playerBullet.x,playerBullet.y);
		playerBullet.fired := false;
		if (fleaEnemy.shotCount = 0) then
		begin
			fleaEnemy.shotCount := 1;
			return;
		end;
		// Flea was already shot once
		Sprite::DrawAt(fleaEnemy.x, fleaEnemy.y, fleaSprite);
		AddScore(20);
		fleaEnemy.shotCount := 2;
		fleaEnemy.animFrame := 0;
		fleaEnemy.enabled := false;
	end;
end;

// Player death sequence
procedure DoPlayerDeathAnim();
begin
	for v:= 1 to 5 do
	begin
		Sprite::DrawAt(playerSnake.x,playerSnake.y,snakeDeathSprite + v);
		PlaySound(Sfx_PlayerDead);	
		DeleteSprite(playerSnake.x,playerSnake.y);
	end;
	playerSnake.x := 16;
	Sprite::DrawAt(playerSnake.x,playerSnake.y,snakeSprite);
end;

// All enemy death sequences
procedure DoEnemyDeathAnim();
begin
	// Test for flea death occurring
	if (fleaEnemy.shotCount < 2) then return;
	// Do flea stuff
	if (fleaEnemy.shotCount = 2) then
	begin
		// Flea death - erase flea
		if (fleaEnemy.animFrame = 0) then 
		begin
			DeleteSprite(fleaEnemy.x, fleaEnemy.y);
			fleaEnemy.animFrame := 1;
			return;
		end
		else begin
			Sprite::DrawAt(fleaEnemy.x, fleaEnemy.y, fleaDeathSprite + fleaEnemy.animFrame);	
		end;
		PlaySound(Sfx_FleaDead);
		Sprite::DrawAt(fleaEnemy.x, fleaEnemy.y, fleaDeathSprite + fleaEnemy.animFrame);
		if (fleaEnemy.animFrame = 4) then
		begin
			fleaEnemy.shotCount := 0;
			fleaEnemy.y := 0;
			return;
		end;
		fleaEnemy.animFrame := fleaEnemy.animFrame + 1;
	end;
end;

// Check if flea and player collided
procedure CheckFleaCollide();
begin
	// If not touching player, ignore
	if (fleaEnemy.enabled = false) then return;
	if (fleaEnemy.x <> playerSnake.x) then return;
	if (fleaEnemy.y < playerSnake.y) then return;
	// Passed the above, so flea and snake are touching
	fleaEnemy.enabled := false;
	DeleteSprite(fleaEnemy.x,fleaEnemy.y);
	DeleteSprite(playerSnake.x,playerSnake.y);
	playerBullet.fired := false;
	DeleteSprite(playerBullet.x,playerBullet.y);
	SubtractLife();
	DoPlayerDeathAnim();
end;

// Move the flea down the screen, dropping mushies on the way
procedure MoveFlea();
begin
	// Speed control
	if (fleaEnemy.shotCount = 0) then
	begin
		fleaEnemy.moveSpeed := fleaEnemy.moveSpeed - 1;
		if (fleaEnemy.moveSpeed = 0) then fleaEnemy.moveSpeed := fleaMovespeed else return;
	end;
	// Erase flea sprite
	Sprite::DrawAt(fleaEnemy.x, fleaEnemy.y, fleaSprite);
	fleaEnemy.y := fleaEnemy.y + 1;
	if (fleaEnemy.y > PlayerYMax) then
	begin
		fleaEnemy.enabled := false;
		DeleteSprite(fleaEnemy.x,fleaEnemy.y - 1);
		DoFleaCheck();
		return;
	end;
	Sprite::DrawAt(fleaEnemy.x, fleaEnemy.y, fleaSprite);
	fleaEnemy.dropCount := fleaEnemy.dropCount + 1;
	PlaySound(Sfx_Flea);
	// Only update every 4 pixels down
	if (fleaEnemy.dropCount = 4) then
	begin
		fleaEnemy.dropCount := 0;
		t := Functions::getRandFromArray(#gridRandoms);
		if (t > 15) then
		begin
			u := GetGridLocVal(fleaEnemy.x, screenYtogridY[fleaEnemy.y - screenYOffset]);
			if (u = 0) then
			begin
				SetGridLocVal(fleaEnemy.x, screenYtogridY[fleaEnemy.y - 4 - screenYOffset], mushroomSprite);
				// Draw new grid sprite
				Sprite::DrawAt(v,lookupScreenY[w]+screenYOffset,t);				
			end;
		end;
	end;
end;

// Drawing Millipede sprite
procedure DrawMilliSprite(s : global byte);
begin
	// Draw Millipede head sprite
	if (IsBitSet(milliSegments[s].flags,Flag_Head)<>false) then
	begin
		if (IsBitSet(milliSegments[s].flags,Flag_MovingRight)<>false) then v := milliSprite+1;
		if (IsBitSet(milliSegments[s].flags,Flag_MovingLeft)<>false) then v := milliSprite+3;
//		if (IsBitSet(milliSegments[s].flags,Flag_MovingUp)<>false) then v := milliSprite+4;
//		if (IsBitSet(milliSegments[s].flags,Flag_MovingDown)<>false) then v := milliSprite+2;
		Sprite::DrawAt(milliSegments[s].x, screenYOffset+lookupScreenY[milliSegments[s].y], v);
		SetGridLocVal(milliSegments[s].x, milliSegments[s].y, milliHead);
	end
	// Millipede body
	else
	begin
		Sprite::DrawAt(milliSegments[s].x,screenYOffset+lookupScreenY[milliSegments[s].y], milliSprite);
		SetGridLocVal(milliSegments[s].x, milliSegments[s].y, milliBody);
	end;
end;

// Move Millipede
procedure MoveMillipede();
begin
	p := 0;
	for s := 0 to milliLength do
	begin
		q := 0;
		if (IsBitSet(milliSegments[s].flags, Flag_Alive)<>false) then
		begin
			// Test if segment is not on grid
			if (milliSegments[s].y = 255) then
			begin
				if (p = 0) then
				begin
					milliSegments[s].y := 0;
					milliSegments[s].x := 16;
					p := 1;
					if (IsBitSet(milliSegments[s].flags,Flag_Head)<>false) then v := milliHead else v := milliBody;
					DrawMilliSprite(s);					
					SetGridLocVal(milliSegments[s].x,milliSegments[s].y,v);
				end;				
			end
			// Segment is already on the grid
			else
			begin
			// Delete sprite
			DrawMilliSprite(s);
			SetGridLocVal(milliSegments[s].x,milliSegments[s].y,0);		
			p := 0; // Did we already switch R/L?
			// Move millipede right?
			if (IsBitSet(milliSegments[s].flags,Flag_MovingRight)<>false) then
			begin
				q := GetGridLocVal(milliSegments[s].x+1, milliSegments[s].y);
				if (q > milliBody - 1) then q := 0; // Don't detect millipede segments
				if (milliSegments[s].x = PlayerXMax) then q := 123; // A hack for edge of screen.
				// Will we collide with a mushroom on the grid or screen edge?
				if (q = 0) then
				begin
					// Move one right
					milliSegments[s].x := milliSegments[s].x + 1;
				end
				else
				begin
					if (IsBitSet(milliSegments[s].flags,Flag_MovingDown)<>false) then
					begin
						milliSegments[s].y := milliSegments[s].y + 1;
						milliSegments[s].flags := ResetBit(milliSegments[s].flags,Flag_MovingRight);	// Disable going right
						milliSegments[s].flags := SetBit(milliSegments[s].flags,Flag_MovingLeft);	// Set Left direction
						p := 1;
					end;
					if (IsBitSet(milliSegments[s].flags,Flag_MovingUp)<>false) then
					begin
						milliSegments[s].y := milliSegments[s].y - 1;
						milliSegments[s].flags := ResetBit(milliSegments[s].flags,Flag_MovingRight);	// Disable going right
						milliSegments[s].flags := SetBit(milliSegments[s].flags,Flag_MovingLeft);	// Set Left direction
						p := 1;
					end;
				end;
			end;	// End moving right
			// Move millipede left?
			if (IsBitSet(milliSegments[s].flags,Flag_MovingLeft)<>false and (p = 0)) then
			begin
				q := GetGridLocVal(milliSegments[s].x-1, milliSegments[s].y);
				if (q > milliBody - 1) then q := 0; // Don't detect millipede segments
				if (milliSegments[s].x = 0) then q := 123; // A hack for edge of screen.
				//Loop();
				// Will we collide with a mushroom on the grid or screen edge?
				if (q = 0) then
				begin
					// Move one left
					milliSegments[s].x := milliSegments[s].x - 1;
				end
				else
				begin
				if (IsBitSet(milliSegments[s].flags,Flag_MovingDown)<>false) then
					begin
						milliSegments[s].y := milliSegments[s].y + 1;
						milliSegments[s].flags := SetBit(milliSegments[s].flags,Flag_MovingRight);	// Disable going right
						milliSegments[s].flags := ResetBit(milliSegments[s].flags,Flag_MovingLeft);	// Set Left direction
					end;
					if (IsBitSet(milliSegments[s].flags,Flag_MovingUp)<>false) then
					begin
						milliSegments[s].y := milliSegments[s].y - 1;
						milliSegments[s].flags := SetBit(milliSegments[s].flags,Flag_MovingRight);	// Disable going right
						milliSegments[s].flags := ResetBit(milliSegments[s].flags,Flag_MovingLeft);	// Set Left direction
					end;
				end;
			end;	// End moving left
			
			// Test if reached top or bottom of area
			p := 0;
			if (IsBitSet(milliSegments[s].flags,Flag_MovingDown)<>false) then
			begin
				if (milliSegments[s].y > MilliYMax) then 
				begin
					milliSegments[s].flags := SetBit(milliSegments[s].flags,Flag_MovingUp); // Set moving up	
					milliSegments[s].flags := ResetBit(milliSegments[s].flags,Flag_MovingDown);		
					p := 1;
				end;	
			end;	
			if (IsBitSet(milliSegments[s].flags,Flag_MovingUp)<>false and (p = 0)) then
			begin
				if (milliSegments[s].y < MilliYMin) then 
				begin
					milliSegments[s].flags := SetBit(milliSegments[s].flags,Flag_MovingDown); // Set moving up
					milliSegments[s].flags := ResetBit(milliSegments[s].flags,Flag_MovingUp);			
				end;	
			end;				
			DrawMilliSprite(s);
			end;
		end;
	end;
end;

// Actual code start
begin
	gameStats.hiScore := 0;
	Memory::DisableInterrupts();
	// Set Graphics mode
	Screen::SetMode(1);
	// Decompress the image to the screen
	Compression::Decompress(#data, #screen); 
	// Set pen colour
	Screen::SetPen(1);
	Font::SetFont(#Font::font1);

	// Do titlescreen stuff
	TitleScreen();
	PlaySound(Sfx_Gamestart);
	InitialiseGame();
	DrawGrid();
	// Keep game going until gameRunning is false (Game over)
	while (gameStats.gameRunning) do
	begin
		// Sync everything so the speed is correct
		Screen::WaitForVerticalBlank();
		playerSnake.moveCount := playerSnake.moveCount - 1;
		if (playerSnake.moveCount = 0) then
		begin
			playerSnake.moveCount := PlayerMoveCount;
			ControlPlayer();
		end;
		if (playerBullet.fired) then
		begin
			MoveBullet();
			if (fleaEnemy.enabled) then CheckFleaShot();
			MoveBullet();
		end;
		if (fleaEnemy.enabled) then
		begin
			// Only move flea if it's not dead.
			if (fleaEnemy.shotCount < 2) then MoveFlea();
			// Check if flea collided with player
			CheckFleaCollide();
			// Check if flea was shot
			if (playerBullet.fired) then CheckFleaShot();
		end;
		// Move Millipede
		milliMoveSpeed := milliMoveSpeed - 1;
		if (milliMoveSpeed = 0) then
		begin
			milliMoveSpeed := MilliMoveCount;
			MoveMillipede();
		end;
		// Test if any enemies shot and if so, animate sprite
		DoEnemyDeathAnim();
	end;
	Loop();

end.