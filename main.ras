program MyProject;
@use "Screen"
@use "Memory"
@use "Compression"
@use "Font"
@use "Input"
@use "Sound"
@use "Functions"
@use "Sprite"

@export "images/title.flf" "title.bin" 256

var  
	// Get data for the title screen
	data : incbin("title.bin") compressed;
	// Constants to make code easier to read
	const gridWidth : byte = 32;
	const gridHeight : byte = 14;
	const fleaSprite : byte = 9;
	const snakeSprite : byte = 10;
	const snakeDeathSprite : byte = 20;
	const scorpionSpriteLeft : byte = 4;
	const mushroomSprite : byte = 4;
	const mushroomSpriteEnd : byte = 5;
	const milliLength : byte = 12;	
	const milliSprite : byte = 12;
	const milliSpriteEnd : byte = 17;
	const milliBody : byte = 5;
	const milliHead : byte = 6;
	const fleaDeathSprite : byte = 20;
	const PlayerYMin : byte = 42;
	const PlayerYMax : byte = 58;
	const PlayerXMax : byte = 31;
	const MilliYMin : byte = 10;
	const MilliYMax : byte = 13;
	const PlayerMoveSpeed : byte = 3;
	const MilliMoveSpeed : byte = 7;
	const ScorpionMoveSpeed : byte = 4;
	const fleaMovespeed : byte = 2;
	const screenYOffset : byte = 6;
	const Sfx_Gamestart : byte = 1;
	const Sfx_Playershoot : byte = 2;
	const Sfx_Flea : byte = 3;
	const Sfx_FleaDead : byte = 4;
	const Sfx_PlayerDead : byte = 5;
	const Sfx_MilliDead : byte = 6;
	const Sfx_Scorpion : byte = 7;
	// Millipede segment flags
	const Flag_MovingLeft : byte = 1;	// No = 0. Yes = 1
	const Flag_MovingRight : byte = 2; // No = 0. Yes = 1
	const Flag_MovingUp : byte = 4;	// Moving Up. No = 0. Yes = 1.
	const Flag_MovingDown : byte = 8; // Moving Down. No = 0. Yes = 1.
	const Flag_Head : byte = 16;		// No = 0. Yes = 1.
	const Flag_Poisoned : byte = 32;	// No poison = 0. Poisoned = 1.
	const Flag_Alive: byte = 64;		// This segment alive? No = 0. Yes = 1.
	
	// Other variables	
	tempint : Integer;
	mychar : string = "A";
	myp, mym : pointer;
	strpos : byte = 0;
	Value, BitFlag: byte;
	// Set up an array for the mushrooms
	gameGrid : array[gridWidth*gridHeight] of byte;
	// Sprite definitions
  smallSprites: array[] of byte =(0,0,0,0,040, 128, 000, 000, 040, 162, 016, 000, 040, 170, 020, 016, 040, 170, 020, 020, 060, 192, 000, 000, 060, 243, 032, 000, 060, 255, 040, 032, 060, 255, 040, 040, 60,223,255,204,20,215,85,20,20,0,0,0,20,85,85,20,23,85,85,23,20,85,85,215,212,85,85,212,215,85,85,20,0,16,0,0,0,16,4,0,0,4,16,0,68,17,68,17,0,48,0,0,0,48,12,0,0,12,48,0,204,51,204,51);
	bigSprites: array[] of byte = (000, 000, 000, 063, 125, 252, 195, 255, 195, 012, 000, 048, 012, 000, 048, 051, 125, 204, 051, 255, 204, 003, 000, 192, 003, 000, 192, 015, 125, 240, 015, 255, 240, 012, 195, 048, 012, 000, 048, 051, 125, 204, 051, 255, 204, 003, 000, 192, 204, 204, 048, 048, 048, 204, 013, 220, 012, 003, 255, 240, 204, 204, 000, 048, 048, 012, 013, 220, 051, 003, 255, 195, 204, 204, 060, 048, 048, 003, 013, 220, 060, 003, 255, 192, 204, 204, 012, 048, 048, 051, 013, 220, 048, 003, 255, 192, 012, 051, 051, 051, 012, 012, 048, 055, 112, 015, 255, 192, 000, 051, 051, 048, 012, 012, 204, 055, 112, 195, 255, 192, 060, 051, 051, 192, 012, 012, 060, 055, 112, 003, 255, 192, 048, 051, 051, 204, 012, 012, 012, 055, 112, 003, 255, 192, 204, 195, 051, 055, 060, 220, 055, 060, 220, 204, 195, 051, 012, 195, 048, 003, 125, 192, 012, 195, 048, 000, 000, 000, 000, 195, 000, 000, 060, 000, 000, 195, 000, 000, 000, 000, 000, 000, 000, 000, 060, 000, 000, 000, 000, 000, 000, 000);
	// Array to look up Y values to speed things up
	lookupGridY : array[gridHeight] of Integer = BuildTable("i*GRIDWIDTH");
	lookupScreenY : array[gridHeight] of Integer = BuildTable("i*4");
	screenYtogridY : array[56] of byte = (0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,6,6,6,6,7,7,7,7,8,8,8,8,9,9,9,9,10,10,10,10,11,11,11,11,12,12,12,12,13,13,13,13);
	bulletYConstrain : array[18] of byte = (41,45,45,45,45,49,49,49,49,53,53,53,53,57,57,57,57,61); // Bullet-mushroom collision code works best this way
	p, q, s, t, u, v, w, x, y : byte; // A bunch of temp multi-use variables
	message : string = "Press 'S' to start! You can use either Joystick or Keys:QA = Up/Down and M, = Left/Right Space to fire. Millipede was developed by Jason Oakley / Blue Bilby using TRSE. Check out more stuff at BlueBilby.com ... ";
	strlen : byte = 210;
	milliSegments_record = record
		x,y : byte;
		lastX,lastY : byte;
		lastGridVal : byte;
		flags : byte;
		end;
	mushroomJustShot_record = record
			x,y : byte;
		end;
	playerSnake_record = record
		moveCount : byte;
		x,y : byte;
	end;
	playerBullet_record = record
		fired : boolean;
		moveCount : byte;
		x,y : byte;
	end;
	flea_record = record
		enabled : boolean;
		dropCount : byte;
		shotCount : byte;
		moveSpeed : byte;
		animFrame : byte;
		x,y : byte;
	end;
	gameStats_record = record
		lives, level : byte;
		score : Integer;
		hiScore : Integer;
		gameRunning : boolean;
		milliSpeed : byte;
	end;
	scorpion_record = record
		enabled : boolean;
		x,y : byte;
		direction : boolean;
		animFrame : byte;
		moveSpeed : byte;
	end;
	playerBullet : playerBullet_record;
	playerSnake : playerSnake_record;
	gameStats : gameStats_record;
	fleaEnemy : flea_record;
	milliSegments : array[milliLength] of milliSegments_record;
  mushroomJustShot : mushroomJustShot_record;
  scorpionEnemy : scorpion_record;

// Procedures	

// Bitwise functions
function IsBitSet(Value, BitFlag: global byte): Boolean;
begin
	IsBitSet := Value & BitFlag;
end;
function SetBit(Value, BitFlag: global byte): Boolean;
begin
	SetBit := Value | BitFlag;
end;
function ResetBit(Value, BitFlag: global byte): Boolean;
begin
	ResetBit := Value - BitFlag;
end;

// Draw and manage Title Screen
procedure TitleScreen();
begin
	myp := #mychar;
	mym := #message;
	v := 0;
	// Keep titlescreen going until S pressed
	while (Input::GetPressedKey() <> Input::Key_S) do
	begin
		// Draw new char in the onscreen scroll every 4 pixels
		if (v = 0) then
		begin
			v := 4;
			myp[0] := mym[strpos];
			Font::DrawTextAt(#mychar,31,58,false);
			if (strpos < strlen) then strpos := strpos + 1 else strpos := 0;
		end;
		for u := 0 to 200 do wait(50);	
		// Smooth scroll the message 1 pixel at a time
		Screen::doSmoothScroll(30559,5);
		v := v - 1;
	end;	
	gameStats.gameRunning := true;
end;

// Sound effects manager
procedure PlaySound(u : global byte);
begin
	// Game start sfx
	case u of
		Sfx_Gamestart:
			begin
				Sound::Play(80,50);
				Sound::Play(50,50);
			end;
		Sfx_Playershoot:
			begin
				Sound::Play(80,10);
				Sound::Play(100,10);
				Sound::Play(120,10);
			end;
		Sfx_Flea:
			begin
				Sound::Play(fleaEnemy.y * 5,3);
			end;
		Sfx_FleaDead:
			begin
				Sound::Shoot(450,200);
			end;
		Sfx_PlayerDead:
			begin
				Sound::Explode();
			end;
		Sfx_MilliDead:
			begin
				Sound::Play(20,30);
				Sound::Play(30,30);
			end;
		Sfx_Scorpion:
			begin
				case scorpionEnemy.animFrame of
					0:
						begin
							Sound::Play(50,10)
						end;
					1:
						begin
							Sound::Play(60,10)
						end;
					2:
						begin
							Sound::Play(70,10)
						end;						
					3:
						begin
							Sound::Play(60,10)
						end;						
				end;
			end;
	end;
end;

// Draw numbers on the screen padded and with trailing zeroes
procedure DrawPadded(zscore : Integer; x, y: global byte);
begin
	u := x;
	if (zscore < 1) then 
	begin
		Font::DrawTextAt("0",u+6,y,false);
		return;
	end;
	if (zscore < 10000) then x := x + 1;
	if (zscore < 1000) then x := x + 1;
	if (zscore < 100) then x := x + 1;
	if (zscore < 10) then x := x + 1;
	Functions::IntegerToString(zscore);
	Font::DrawTextAt(#Functions_s,x,y,false);	
	Font::DrawTextAt("0",u+6,y,false);
end;

// Draw Headsup Display.
procedure DrawHUD();
begin
	// Draw lives
	Screen::SetPen(3);
	Font::DrawTextAt("Score:",19,0,false);
	Font::DrawTextAt("Lives:",0,0,false);
	Font::DrawTextAt("Hi:",8,0,false);
	Screen::SetPen(1);
	DrawPadded(gameStats.score,24,0);
	DrawPadded(gameStats.hiScore,10,0);
	Functions::ByteToString(gameStats.lives);
	Font::DrawTextAt(#Functions_s,6,0,false);
end;

// Initialise stuff
procedure InitialiseGame();
begin
	// Scroll titlescreen off to the left
	for v := 0 to 32 do
	begin
		Screen::doCoarseScroll(28672,63);
		for u := 0 to 30 do wait(140);	
	end;
	// Initialise grid
	for u := 0 to 255 do gameGrid[u] := 0;
	for u := 0 to (gridWidth * gridHeight) - 255 do gameGrid[u+256] := 0;
	// Initialise millipede
	for u:= 0 to milliLength do
	begin
		milliSegments[u].flags := 74;	 // Initial direction set to right, down and set to alive body segment.
		milliSegments[u].y := 255; // A large number to note the segment is not on the grid yet.
	end;
	milliSegments[0].flags := 90;	 // Alive, direction right, down and head segment.
	gameStats.milliSpeed := MilliMoveSpeed;
	// Initialise variables
	gameStats.lives := 3;
	gameStats.score := 0;
	gameStats.level := 1;
	playerSnake.x := 16;
	playerSnake.y := 58;
	playerSnake.moveCount := PlayerMoveSpeed;
	playerBullet.fired := false;
	fleaEnemy.enabled := false;
	scorpionEnemy.enabled := false;
	DrawHUD();
	// Draw player sprite
	Sprite::SetData(#smallSprites);
	Sprite::SetSize(1,4);	
	Sprite::DrawAt(playerSnake.x,playerSnake.y,snakeSprite,false);
	if (gameStats.level = 1) then return;
end;

// Initialise the mushrooms in an array grid and display
procedure DrawGrid();
begin
	Sprite::SetData(#smallSprites);
	Sprite::SetSize(1,4);
	// Playfield grid array
	for y := 0 to gridHeight - 1 do
	begin
		x := Functions::getRandomByte(31);	
		tempint := lookupGridY[y] + x;
		gameGrid[tempint] := mushroomSprite;
		Sprite::DrawAt(x,screenYOffset+lookupScreenY[y],mushroomSprite,false);
		p := Functions::getRandomByte(31);	
		while (p = x) do p := Functions::getRandomByte(31);	
		x := p;
		tempint := lookupGridY[y] + x;
		gameGrid[tempint] := mushroomSprite;
		Sprite::DrawAt(x,screenYOffset+lookupScreenY[y],mushroomSprite,false);
	end;
end;

// Calculate the player's position in the mushroom grid
// to compare if colliding with mushrooms or millipede
function GetGridLocVal(v,w : global byte):byte;
begin
	tempint := lookupGridY[w]+v;
	// Return value from function call
	GetGridLocVal := gameGrid[tempint];
end;

// Update value at grid location
procedure SetGridLocVal(v,w,t : global byte);
begin
	tempint := lookupGridY[w]+v;
	// Update grid value
	gameGrid[tempint] := t;
end;

// Update Lives HUD
procedure SubtractLife();
begin
	gameStats.lives := gameStats.lives - 1;
	// Check if Game Over
	if (gameStats.lives = 0) then
	begin
		// Player dead. TODO
		gameStats.gameRunning := false;
	end;
	DrawHUD();
end;

// Add points to player's score
procedure AddScore(t : global byte);
begin
	gameStats.score := gameStats.score + t;
	DrawHUD();
end;

// Delete a sprite - is redundant now but useful to show inline assembly
procedure DeleteSprite(x, y : global byte);
begin
	tempint := #screen + Screen::tab32[y] + x;
	asm("
	ld a,[tempint+1]
	ld h,a
	ld a,[tempint]
	ld l,a
	ld de,#0020
	ld (hl),#00
	add hl,de
	ld (hl),#00
	add hl,de
	ld (hl),#00
	add hl,de
	ld (hl),#00
	add hl,de	
	");
end;

// Draw Bullet
procedure DrawBullet(x,y : global byte);
begin
	tempint := #screen + Screen::tab32[y] + x;
	Screen::Poke(tempint,20);
end;

// Delete Bullet
procedure DeleteBullet(x,y : global byte);
begin
	tempint := #screen + Screen::tab32[y] + x;
	Screen::Poke(tempint,0);	
end;

// Get player input and move snake head
procedure ControlPlayer();
begin
	// Get player input
	u := Input::GetJoystick(1);
	v := Input::GetJoystick(2);
	w := Input::GetPressedKey();
	Sprite::DrawAt(playerSnake.x,playerSnake.y,snakeSprite,false);
	// Test for player movement
	if (u = Input::Joy_None and (v = Input::Joy_None and (w = Input::Key_None))) then return;
	// Player shooting
	if (u = Input::Joy_Fire or (v = Input::Joy_Fire or (w = Input::Key_SPC))) then
	begin
		// Test if a bullet already exists onscreen. Snake can only shoot once at a time
		if (playerBullet.fired) then return;
		playerBullet.fired := true;
		PlaySound(Sfx_Playershoot);
		playerBullet.x := playerSnake.x;
		playerBullet.y := bulletYConstrain[playerSnake.y - PlayerYMin ];
		DrawBullet(playerBullet.x,playerBullet.y);
		return;
	end;		
  // Erase player sprite
	DeleteSprite(playerSnake.x,playerSnake.y);
	// Check if player wants to move UP
	if (u = Input::Joy_Up or (v = Input::Joy_Up or (w = Input::Key_Q))) then
	begin
		// Make sure we're not already at the top of the player area
		if (playerSnake.y > PlayerYMin) then 
		begin
			// Move player y pos
			playerSnake.y := playerSnake.y - 1;
			// Test if we're colliding with a mushroom. If so, move player y back
			if (GetGridLocVal(playerSnake.x,screenYtogridY[playerSnake.y - screenYOffset]) > 0) then playerSnake.y := playerSnake.y + 1;
		end;
	end;
	if (u = Input::Joy_Down or (v = Input::Joy_Down or (w = Input::Key_A))) then
	begin
		if (playerSnake.y < PlayerYMax) then 
		begin
			// Due to player sprite being 4 pixels high we need to check 4 below the Y value.
			playerSnake.y := playerSnake.y + 4;
			u := GetGridLocVal(playerSnake.x,screenYtogridY[playerSnake.y + 3 - screenYOffset]);
			
			// If a mushroom is below the player, move the y back to where it was, otherwise move one pixel down
			if (GetGridLocVal(playerSnake.x,screenYtogridY[playerSnake.y - screenYOffset]) > 0) then playerSnake.y := playerSnake.y - 4 else playerSnake.y := playerSnake.y - 3;
		end;
	end;	
	if (u = Input::Joy_Left or (v = Input::Joy_Left or (w = Input::Key_M))) then
	begin
		if (playerSnake.x > 0) then
		begin
			playerSnake.x := playerSnake.x - 1;
			if (GetGridLocVal(playerSnake.x,screenYtogridY[playerSnake.y - screenYOffset]) > 0) then playerSnake.x := playerSnake.x + 1;
			// Test bottom of sprite
			if (GetGridLocVal(playerSnake.x,screenYtogridY[playerSnake.y + 3 - screenYOffset]) > 0) then playerSnake.x := playerSnake.x + 1;
		end;
	end;
	if (u = Input::Joy_Right or (v = Input::Joy_Right or (w = Input::Key_COMMA))) then
	begin
		if (playerSnake.x < PlayerXMax) then
		begin
			playerSnake.x := playerSnake.x + 1;
			if (GetGridLocVal(playerSnake.x,screenYtogridY[playerSnake.y - screenYOffset]) > 0) then playerSnake.x := playerSnake.x - 1;		
			// Test bottom of sprite
			if (GetGridLocVal(playerSnake.x,screenYtogridY[playerSnake.y + 3 - screenYOffset]) > 0) then playerSnake.x := playerSnake.x - 1;			
		end;
	end;
	// Draw player sprite at new location
	Sprite::DrawAt(playerSnake.x,playerSnake.y,snakeSprite,false);
end;

// Check if we need to put a flea on the screen
procedure ShouldFleaDrop();
begin
	t := 0;
	for u := 0 to 160 do
	begin
		v := gameGrid[u+256];
		if (v > mushroomSprite - 1 and (v < mushroomSpriteEnd)) then t := t + 1;
		if (t > 5) then return;
	end;
	fleaEnemy.enabled := true;
	fleaEnemy.x := Functions::getRandomByte(31);
	fleaEnemy.y := screenYOffset + 4;
	fleaEnemy.moveSpeed := fleaMovespeed;
	fleaEnemy.shotCount := 0;
	fleaEnemy.dropCount := 0;
	Sprite::DrawAt(fleaEnemy.x, fleaEnemy.y, fleaSprite,false);
end;

// Player fired
procedure MoveBullet();
begin
	// Erase sprite
	DeleteBullet(playerBullet.x,playerBullet.y);
	playerBullet.y := playerBullet.y - 1;
	if (playerBullet.y < screenYOffset + 1) then
	begin
		playerBullet.fired := false;
		return;
	end;
	// Find out any values in the grid at the bullet location
	s := GetGridLocVal(playerBullet.x,screenYtogridY[playerBullet.y - screenYOffset]);
	// Collided with something on the grid
	if (s > 0) then
	begin
		// Turn bullet off
		playerBullet.fired := false;
		// Test for mushies
		if (s > 0 and (s < mushroomSpriteEnd)) then
		begin
			// Mushy at this grid loc
			if (s < mushroomSpriteEnd) then
			begin
				DeleteSprite(v,lookupScreenY[w]+screenYOffset);	
				s := s - 1;
				// Update value in grid location
				SetGridLocVal(playerBullet.x,screenYtogridY[playerBullet.y - screenYOffset],s);
				// Draw new grid sprite
				Sprite::DrawAt(v,lookupScreenY[w]+screenYOffset,s,false);				
			end;
			if (s = 0) then 
			begin
				// Delete mushy
				SetGridLocVal(playerBullet.x,screenYtogridY[playerBullet.y-screenYOffset],0);
				// Draw new grid sprite
				DeleteSprite(v,lookupScreenY[w]+screenYOffset);				
				AddScore(1);
				mushroomJustShot.x := playerBullet.x;
				mushroomJustShot.y := screenYtogridY[playerBullet.y-screenYOffset];
				// See if number of mushies in player area needs updating
				if (fleaEnemy.enabled = false) then ShouldFleaDrop();
			end;
		end;
	end;
	// Check for shot millipede segment
	if (s = milliBody or (s = milliHead)) then
	begin
		// Update value in grid location
		q := screenYtogridY[playerBullet.y - screenYOffset];
		for p := 0 to milliLength do
		begin
			if (milliSegments[p].y = q) then
			begin
				if (milliSegments[p].x = playerBullet.x) then // bullet and millipede are same Grid Location
				begin
					if (IsBitSet(milliSegments[p].flags,Flag_Alive)) then
					begin
						milliSegments[p].flags := ResetBit(milliSegments[p].flags,Flag_Alive);	
						if (s = milliBody) then AddScore(5) else AddScore(50);
						if (p < milliLength) then
						begin
							milliSegments[p+1].flags := SetBit(milliSegments[p+1].flags,Flag_Head);
						end;	
						PlaySound(Sfx_MilliDead);
						DeleteSprite(milliSegments[p].x,lookupScreenY[milliSegments[p].y]+screenYOffset);					
						SetGridLocVal(playerBullet.x,q,mushroomSprite);
						Sprite::DrawAt(playerBullet.x,lookupScreenY[milliSegments[p].y]+screenYOffset,mushroomSprite,false);
					end;
				end;
			end;
		end;
	end;
	// Draw sprite at new location onscreen
	if (playerBullet.fired) then DrawBullet(playerBullet.x,playerBullet.y);
end;

// Did the player shoot the flea?
procedure CheckFleaShot();
begin
	if (fleaEnemy.x <> playerBullet.x) then return;
	t := playerBullet.y;
	u := fleaEnemy.y;
	v := fleaEnemy.y + 5;
	if (t < v and (t > u)) then
	// Flea shot by player
	begin
		// Erase bullet
		DeleteBullet(playerBullet.x,playerBullet.y);
		playerBullet.fired := false;
		if (fleaEnemy.shotCount = 0) then
		begin
			fleaEnemy.shotCount := 1;
			return;
		end;
		// Flea was already shot once
		Sprite::DrawAt(fleaEnemy.x, fleaEnemy.y, fleaSprite,false);
		AddScore(20);
		fleaEnemy.shotCount := 2;
		fleaEnemy.animFrame := 0;
		fleaEnemy.enabled := false;
	end;
end;

// Player death sequence
procedure DoPlayerDeathAnim();
begin
	for v:= 1 to 5 do
	begin
		Sprite::DrawAt(playerSnake.x,playerSnake.y,snakeDeathSprite + v,false);
		PlaySound(Sfx_PlayerDead);	
		DeleteSprite(playerSnake.x,playerSnake.y);
	end;
	playerSnake.x := 16;
	Sprite::DrawAt(playerSnake.x,playerSnake.y,snakeSprite,false);
end;

// All enemy death sequences
procedure DoEnemyDeathAnim();
begin
	// Test for flea death occurring
	if (fleaEnemy.shotCount < 2) then return;
	// Do flea stuff
	if (fleaEnemy.shotCount = 2) then
	begin
		// Flea death - erase flea
		if (fleaEnemy.animFrame = 0) then 
		begin
			DeleteSprite(fleaEnemy.x, fleaEnemy.y);
			fleaEnemy.animFrame := 1;
			return;
		end
		else begin
			Sprite::DrawAt(fleaEnemy.x, fleaEnemy.y, fleaDeathSprite + fleaEnemy.animFrame,false);	
		end;
		PlaySound(Sfx_FleaDead);
		Sprite::DrawAt(fleaEnemy.x, fleaEnemy.y, fleaDeathSprite + fleaEnemy.animFrame,false);
		if (fleaEnemy.animFrame = 4) then
		begin
			DeleteSprite(fleaEnemy.x,fleaEnemy.y);
			fleaEnemy.shotCount := 0;
			fleaEnemy.y := 0;
			ShouldFleaDrop();
			return;
		end;
		fleaEnemy.animFrame := fleaEnemy.animFrame + 1;
	end;
end;

// Check if flea and player collided
procedure CheckFleaCollide();
begin
	// If not touching player, ignore
	if (fleaEnemy.enabled = false) then return;
	if (fleaEnemy.x <> playerSnake.x) then return;
	if (fleaEnemy.y < playerSnake.y) then return;
	// Passed the above, so flea and snake are touching
	fleaEnemy.enabled := false;
	DeleteSprite(fleaEnemy.x,fleaEnemy.y);
	DeleteSprite(playerSnake.x,playerSnake.y);
	playerBullet.fired := false;
	DeleteSprite(playerBullet.x,playerBullet.y);
	SubtractLife();
	DoPlayerDeathAnim();
end;

// Move the flea down the screen, dropping mushies on the way
procedure MoveFlea();
begin
	// Speed control
	if (fleaEnemy.shotCount = 0) then
	begin
		fleaEnemy.moveSpeed := fleaEnemy.moveSpeed - 1;
		if (fleaEnemy.moveSpeed = 0) then fleaEnemy.moveSpeed := fleaMovespeed else return;
	end;
	// Erase flea sprite
	Sprite::DrawAt(fleaEnemy.x, fleaEnemy.y, 0,false);
	fleaEnemy.y := fleaEnemy.y + 1;
	// Disable if reached bottom of screen
	if (fleaEnemy.y > PlayerYMax) then
	begin
		fleaEnemy.enabled := false;
		DeleteSprite(fleaEnemy.x,fleaEnemy.y - 1);
		ShouldFleaDrop();
		return;
	end;
	Sprite::DrawAt(fleaEnemy.x, fleaEnemy.y, fleaSprite,false);
	fleaEnemy.dropCount := fleaEnemy.dropCount + 1;
	PlaySound(Sfx_Flea);
	// Only update every 4 pixels down
	if (fleaEnemy.dropCount = 4) then
	begin
	fleaEnemy.dropCount := 0;
	t := Functions::getRandomByte(31);
	if (t > 15) then
		begin
			SetGridLocVal(fleaEnemy.x, screenYtogridY[fleaEnemy.y - 4 - screenYOffset], mushroomSprite);
			// Draw new grid sprite
			Sprite::DrawAt(fleaEnemy.x, fleaEnemy.y  - 4, mushroomSprite, false);  //HERE!
		end
		else
		begin
			SetGridLocVal(fleaEnemy.x, screenYtogridY[fleaEnemy.y - 4 - screenYOffset], 0);	
		end;
	end;
end;

// Drawing Millipede sprite
procedure DrawMilliSprite(s : global byte);
begin
	// Draw Millipede head sprite
	if (IsBitSet(milliSegments[s].flags,Flag_Head)<>false) then
	begin
		if (IsBitSet(milliSegments[s].flags,Flag_MovingRight)<>false) then v := milliSprite+1;
		if (IsBitSet(milliSegments[s].flags,Flag_MovingLeft)<>false) then v := milliSprite+3;
		Sprite::DrawAt(milliSegments[s].x, screenYOffset+lookupScreenY[milliSegments[s].y], v,false);
		SetGridLocVal(milliSegments[s].x, milliSegments[s].y, milliHead);
	end
	// Millipede body
	else
	begin
		Sprite::DrawAt(milliSegments[s].x,screenYOffset+lookupScreenY[milliSegments[s].y], milliSprite,false);
		SetGridLocVal(milliSegments[s].x, milliSegments[s].y, milliBody);
	end;
end;

// Did player shoot a mushroom?
procedure CheckMushroomShot();
begin
	// Don't change direction if mushroom just shot
	if (mushroomJustShot.x = milliSegments[s].x and (mushroomJustShot.y = milliSegments[s].y)) then
	begin
		q := 1;
		mushroomJustShot.x := 0;
		mushroomJustShot.y := 0;
	end;
end;

// Reset mushrooms, etc under scorpion
procedure 	ResetScorpionGrid();
begin
	u := GetGridLocVal(scorpionEnemy.x,screenYtogridY[scorpionEnemy.y - screenYOffset]);
	Sprite::DrawAt(scorpionEnemy.x,scorpionEnemy.y,u,false);
	u := GetGridLocVal(scorpionEnemy.x+1,screenYtogridY[scorpionEnemy.y - screenYOffset]);
	Sprite::DrawAt(scorpionEnemy.x+1,scorpionEnemy.y,u,false);
	u := GetGridLocVal(scorpionEnemy.x+2,screenYtogridY[scorpionEnemy.y - screenYOffset]);
	Sprite::DrawAt(scorpionEnemy.x+2,scorpionEnemy.y,u,false);	
end;

// Move scorpion
procedure MoveScorpion();
begin
	scorpionEnemy.moveSpeed := scorpionEnemy.moveSpeed - 1;
	if (scorpionEnemy.moveSpeed = 0) then scorpionEnemy.moveSpeed := ScorpionMoveSpeed else return;
	// Erase scorpion sprite
	DeleteSprite(scorpionEnemy.x,scorpionEnemy.y);
	DeleteSprite(scorpionEnemy.x+1,scorpionEnemy.y);
	DeleteSprite(scorpionEnemy.x+2,scorpionEnemy.y);
	scorpionEnemy.animFrame := scorpionEnemy.animFrame + 1;
	if (scorpionEnemy.animFrame = 4) then scorpionEnemy.animFrame := 0;
	if (scorpionEnemy.direction) then // Moving Right
	begin
		// Set start sprite
		p := scorpionSpriteLeft + 4;
		// Check for mushrooms under scorpion sprite left half
		u := GetGridLocVal(scorpionEnemy.x,screenYtogridY[scorpionEnemy.y - screenYOffset]);
		if (u < mushroomSpriteEnd) then
		begin
			u := u + 4;
			Sprite::DrawAt(scorpionEnemy.x,scorpionEnemy.y,u,false);
			u := u + 2;
			SetGridLocVal(scorpionEnemy.x,screenYtogridY[scorpionEnemy.y - screenYOffset],u);	
		end
		else
		begin
			Sprite::DrawAt(scorpionEnemy.x,scorpionEnemy.y,u,false);
		end;
		if (scorpionEnemy.x < PlayerXMax - 2) then
		begin
			scorpionEnemy.x := scorpionEnemy.x + 1;
		end
		else
		begin
			scorpionEnemy.enabled := false;
			ResetScorpionGrid();
		end;
	end;

	if (scorpionEnemy.direction = false) then // Moving Left
	begin
		// Set start sprite
		p := scorpionSpriteLeft;
		// Check for mushrooms under scorpion sprite right half
		u := GetGridLocVal(scorpionEnemy.x + 2,screenYtogridY[scorpionEnemy.y - screenYOffset]);
		if (u < mushroomSpriteEnd) then
		begin
			u := u + 4;
			Sprite::DrawAt(scorpionEnemy.x + 2,scorpionEnemy.y,u,false);
			u := u + 2;
			SetGridLocVal(scorpionEnemy.x + 2,screenYtogridY[scorpionEnemy.y - screenYOffset],u);	
		end
		else
		begin
			Sprite::DrawAt(scorpionEnemy.x + 2,scorpionEnemy.y,u,false);
		end;
		if (scorpionEnemy.x > 0) then
		begin
			scorpionEnemy.x := scorpionEnemy.x - 1;
		end
		else
		begin
			scorpionEnemy.enabled := false;
			ResetScorpionGrid();			
		end;
	end;
	if (scorpionEnemy.enabled<>false) then 
	begin
		// Play sound effect
		PlaySound(Sfx_Scorpion);
		// Update sprite data
		Sprite::SetData(#bigSprites);
		Sprite::SetSize(3,4);	
		// Draw scorpion sprite
		Sprite::DrawAt(scorpionEnemy.x,scorpionEnemy.y,p + scorpionEnemy.animFrame,false);
		// Reset sprite data
		Sprite::SetData(#smallSprites);
		Sprite::SetSize(1,4);	
	end;
end;

// Spawn scorpion
procedure SpawnScorpion();
begin
	// Pick a random number to see if we spawn it
	t := Functions::getRandomByte(100);	
	
	// Spawn on the random side
	if (t > 70) then	
	begin
		// Pick a random side of the screen to spawn a scorpion
		t := Functions::getRandomByte(31);
		// Spawn on the random side
		if (t > 15) then	
		begin
			scorpionEnemy.x := PlayerXMax - 2;
			t := Functions::getRandomByte(7);	
			scorpionEnemy.y := t * 4 + screenYOffset;
			scorpionEnemy.direction := false;
		end
		else
		begin
			scorpionEnemy.x := 0;
			t := Functions::getRandomByte(7);	
			scorpionEnemy.y := t * 4 + screenYOffset;
			scorpionEnemy.direction := true;
		end;	
		scorpionEnemy.enabled := true;
		scorpionEnemy.animFrame := 0;
		scorpionEnemy.moveSpeed := ScorpionMoveSpeed;
	end;
end;

// If Millipede reaches the bottom, see if a new head can be spawned
procedure SpawnMillipedeHead();
begin
	// Find unused millipede part in array
	for u := 0 to milliLength do
	begin	
		if (IsBitSet(milliSegments[u].flags, Flag_Alive) = false) then
		begin
			// Pick a random side of the screen to spawn a new head
			t := Functions::getRandomByte(31);	
			// Spawn on the random side
			if (t > 15) then	
			begin
				milliSegments[u].x := PlayerXMax;
				milliSegments[u].flags := 89;
			end
			else
			begin
				milliSegments[u].x := 0;
				milliSegments[u].flags := 90;
			end;
			milliSegments[u].y := 9; // Millipede y value is grid-based
			milliSegments[u].lastGridVal := 0;
			SetGridLocVal(milliSegments[u].x,milliSegments[u].y,milliHead);
			DrawMilliSprite(u);
			return;
		end;
	end;
end;

// Move Millipede
procedure MoveMillipede();
begin
	p := 0;
	for s := 0 to milliLength do
	begin
		q := 0;
		if (IsBitSet(milliSegments[s].flags, Flag_Alive)<>false) then
		begin
			// Test if segment is not on grid
			if (milliSegments[s].y = 255) then
			begin
				// Only one segment at a time to go into the grid
				if (p = 0) then
				begin
					milliSegments[s].y := 0;
					milliSegments[s].x := 16;
					milliSegments[s].lastGridVal := 0;
					p := 1;
					if (IsBitSet(milliSegments[s].flags,Flag_Head)<>false) then v := milliHead else v := milliBody;
					DrawMilliSprite(s);					
					SetGridLocVal(milliSegments[s].x,milliSegments[s].y,v);
				end;				
			end
			// Segment is already on the grid
			else
			begin
			// Delete sprite
			DeleteSprite(milliSegments[s].x,screenYOffset+lookupScreenY[milliSegments[s].y]);
     // Millipede body segments
			if (milliSegments[s].lastGridVal < milliBody) then begin
				SetGridLocVal(milliSegments[s].x,milliSegments[s].y,milliSegments[s].lastGridVal);	
				Sprite::DrawAt(milliSegments[s].x,screenYOffset+lookupScreenY[milliSegments[s].y],milliSegments[s].lastGridVal,false);										
			end
			else
			begin
				SetGridLocVal(milliSegments[s].x,milliSegments[s].y,0);	
			end;	
     // Only direction changing logic in millipede heads
      if IsBitSet(milliSegments[s].flags, Flag_Head) then
				begin
					// Check if the millipede segment is on top of the snake. If so, redraw snake so it doesn't vanish
					if (screenYOffset+lookupScreenY[milliSegments[s].y] > playerSnake.y - 4) then
					begin
						if (screenYOffset+lookupScreenY[milliSegments[s].y] < playerSnake.y + 3) then
						begin
							if (	milliSegments[s].x = playerSnake.x) then
							begin
								Sprite::DrawAt(playerSnake.x,playerSnake.y,snakeSprite,false);	
							end;				
						end;
					end;
					p := 0; // Did we already switch R/L?
					// Move millipede right?
					if (IsBitSet(milliSegments[s].flags,Flag_MovingRight)<>false) then
					begin
						q := GetGridLocVal(milliSegments[s].x+1, milliSegments[s].y);
						CheckMushroomShot();
						if (q > milliBody - 1) then q := 0; // Don't detect millipede segments
						if (milliSegments[s].x = PlayerXMax) then q := 123; // A hack for edge of screen.
						// Will we collide with a mushroom on the grid or screen edge?
						if (q = 0) then
						begin
							// Save current position
							milliSegments[s].lastX := milliSegments[s].x; milliSegments[s].lastY := milliSegments[s].y;
							// Move one right
							milliSegments[s].x := milliSegments[s].x + 1;
							if (GetGridLocVal(milliSegments[s].x, milliSegments[s].y) < milliBody) then milliSegments[s].lastGridVal := GetGridLocVal(milliSegments[s].x, milliSegments[s].y);
						end
						else
						begin
							if (IsBitSet(milliSegments[s].flags,Flag_MovingDown)<>false) then
							begin
								// Try spawning the scorpion
								if (scorpionEnemy.enabled = false) then SpawnScorpion();
								// Save current position
								milliSegments[s].lastX := milliSegments[s].x; milliSegments[s].lastY := milliSegments[s].y;								
								milliSegments[s].y := milliSegments[s].y + 1;
								if (GetGridLocVal(milliSegments[s].x, milliSegments[s].y) < milliBody) then milliSegments[s].lastGridVal := GetGridLocVal(milliSegments[s].x, milliSegments[s].y);
								milliSegments[s].flags := ResetBit(milliSegments[s].flags,Flag_MovingRight);	// Disable going right
								milliSegments[s].flags := SetBit(milliSegments[s].flags,Flag_MovingLeft);	// Set Left direction
								p := 1;
							end;
							if (IsBitSet(milliSegments[s].flags,Flag_MovingUp)<>false) then
							begin
								// Save current position
								milliSegments[s].lastX := milliSegments[s].x; milliSegments[s].lastY := milliSegments[s].y;								
								milliSegments[s].y := milliSegments[s].y - 1;
								if (GetGridLocVal(milliSegments[s].x, milliSegments[s].y) < milliBody) then milliSegments[s].lastGridVal := GetGridLocVal(milliSegments[s].x, milliSegments[s].y);
								milliSegments[s].flags := ResetBit(milliSegments[s].flags,Flag_MovingRight);	// Disable going right
								milliSegments[s].flags := SetBit(milliSegments[s].flags,Flag_MovingLeft);	// Set Left direction
								p := 1;
							end;
						end;
					end;	// End moving down
					// Move millipede left?
					if (IsBitSet(milliSegments[s].flags,Flag_MovingLeft)<>false and (p = 0)) then
					begin
						q := GetGridLocVal(milliSegments[s].x-1, milliSegments[s].y);
						CheckMushroomShot();				
						if (q > milliBody - 1) then q := 0; // Don't detect millipede segments
						if (milliSegments[s].x = 0) then q := 123; // A hack for edge of screen.
						// Will we collide with a mushroom on the grid or screen edge?
						if (q = 0) then
						begin
							// Save current position
							milliSegments[s].lastX := milliSegments[s].x; milliSegments[s].lastY := milliSegments[s].y;
							// Move one left
							milliSegments[s].x := milliSegments[s].x - 1;
							if (GetGridLocVal(milliSegments[s].x, milliSegments[s].y) < milliBody) then milliSegments[s].lastGridVal := GetGridLocVal(milliSegments[s].x, milliSegments[s].y);						
						end
						else
						begin
						if (IsBitSet(milliSegments[s].flags,Flag_MovingDown)<>false) then
							begin
								// Try spawning the scorpion
								if (scorpionEnemy.enabled = false) then SpawnScorpion();								
								// Save current position
								milliSegments[s].lastX := milliSegments[s].x; milliSegments[s].lastY := milliSegments[s].y;					
								milliSegments[s].y := milliSegments[s].y + 1;
								milliSegments[s].lastGridVal := GetGridLocVal(milliSegments[s].x, milliSegments[s].y);
								milliSegments[s].flags := SetBit(milliSegments[s].flags,Flag_MovingRight);	// Disable going right
								milliSegments[s].flags := ResetBit(milliSegments[s].flags,Flag_MovingLeft);	// Set Left direction
							end;
							if (IsBitSet(milliSegments[s].flags,Flag_MovingUp)<>false) then
							begin
								// Save current position
								milliSegments[s].lastX := milliSegments[s].x; milliSegments[s].lastY := milliSegments[s].y;															
								milliSegments[s].y := milliSegments[s].y - 1;
								if (GetGridLocVal(milliSegments[s].x, milliSegments[s].y) < milliBody) then milliSegments[s].lastGridVal := GetGridLocVal(milliSegments[s].x, milliSegments[s].y);
								milliSegments[s].flags := SetBit(milliSegments[s].flags,Flag_MovingRight);	// Disable going right
								milliSegments[s].flags := ResetBit(milliSegments[s].flags,Flag_MovingLeft);	// Set Left direction
							end;
						end;
					end;	// End moving left
					
					// Test if reached top or bottom of area
					p := 0;
					if (IsBitSet(milliSegments[s].flags,Flag_MovingDown)<>false) then
					begin
						if (milliSegments[s].y > MilliYMax) then 
						begin
							milliSegments[s].flags := SetBit(milliSegments[s].flags,Flag_MovingUp); // Set moving up	
							milliSegments[s].flags := ResetBit(milliSegments[s].flags,Flag_MovingDown);		
							milliSegments[s].y := MilliYMax;
							p := 1;
							SpawnMillipedeHead();
						end;	
					end;	
					if (IsBitSet(milliSegments[s].flags,Flag_MovingUp)<>false and (p = 0)) then
					begin
						if (milliSegments[s].y < MilliYMin) then 
						begin
							milliSegments[s].flags := SetBit(milliSegments[s].flags,Flag_MovingDown); // Set moving up
							milliSegments[s].flags := ResetBit(milliSegments[s].flags,Flag_MovingUp);
						end;
					end;	
						DrawMilliSprite(s);
        end
        else
        begin          
          milliSegments[s].lastX := milliSegments[s].x;
          milliSegments[s].lastY := milliSegments[s].y;
          milliSegments[s].x := milliSegments[s-1].lastX;
          milliSegments[s].y := milliSegments[s-1].lastY;
          DrawMilliSprite(s);
        end;
			end;
		end;
		// Reset mushroom just shot storage
		mushroomJustShot.x := 0;
		mushroomJustShot.y := 0;
	end;
end;

// Actual code start
begin
	gameStats.hiScore := 0;
	Memory::DisableInterrupts();
	// Set Graphics mode
	Screen::SetMode(1);
	// Decompress the image to the screen
	Compression::Decompress(#data, #screen); 
	// Set pen colour
	Screen::SetPen(1);
	Font::SetFont(#Font::font1);

	// Do titlescreen stuff
	TitleScreen();
	PlaySound(Sfx_Gamestart);
	InitialiseGame();
	DrawGrid();
	// Keep game going until gameRunning is false (Game over)
	while (gameStats.gameRunning) do
	begin
		// Sync everything so the speed is correct
		Screen::WaitForVerticalBlank();
		// Try spawning scorpion
		if (scorpionEnemy.enabled <> false) then MoveScorpion();
		if (fleaEnemy.enabled) then
		begin
			// Only move flea if it's not dead.
			if (fleaEnemy.shotCount < 2) then MoveFlea();
			// Check if flea collided with player
			CheckFleaCollide();
			// Check if flea was shot
			if (playerBullet.fired) then CheckFleaShot();
		end;
		// Move Millipede
		gameStats.milliSpeed := gameStats.milliSpeed - 1;
		if (gameStats.milliSpeed = 0) then
		begin
			gameStats.milliSpeed := MilliMoveSpeed;
			MoveMillipede();
		end;
		playerSnake.moveCount := playerSnake.moveCount - 1;
		if (playerSnake.moveCount = 0) then
		begin
			playerSnake.moveCount := PlayerMoveSpeed;
			ControlPlayer();
		end;		
		if (playerBullet.fired) then
		begin
			MoveBullet();
			if (fleaEnemy.enabled) then CheckFleaShot();
			MoveBullet();
		end;		
		// Test if any enemies shot and if so, animate sprite
		DoEnemyDeathAnim();
	end;
	Loop();

end.